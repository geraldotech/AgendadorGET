import schedule
import time
import requests
import os
import json
import logging
from pathlib import Path

""" 
VERSAO VERIFICA STATUS INDIVIDUALMENTE
"""


# Configurar o sistema de logs
logging.basicConfig(
    filename='info.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

# Criar um logger espec√≠fico para sucessos (log_success.log)
success_logger = logging.getLogger('success_logger')
success_logger.setLevel(logging.INFO)
success_handler = logging.FileHandler('log_success.log')
success_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S'))
success_logger.addHandler(success_handler)

# Impede que as mensagens do success_logger sejam enviadas para o log geral
success_logger.propagate = False

# Impede que as mensagens do success_logger sejam enviadas para o log geral
#success_logger.info("Teste de escrita no log de sucesso.")


# Vari√°vel global para armazenar as configura√ß√µes
config = None
# Vari√°vel para armazenar o √∫ltimo timestamp de modifica√ß√£o
ultima_modificacao = None

# Caminho fixo relativo (sempre /db/config.json)
config_path = Path('db') / 'config.json'

# Fun√ß√£o para carregar o arquivo JSON
def carregar_config():
    global config, ultima_modificacao

    try:
        # with open(config_path, 'r') as file:
        with open(config_path, 'r', encoding='utf-8') as file:
            config = json.load(file)
            logging.info("Arquivo config.json carregado com sucesso.")
           # print("Configura√ß√µes carregadas com sucesso!")
           # print o json  print(config)
            # Atualiza o timestamp da √∫ltima modifica√ß√£o
            ultima_modificacao = os.path.getmtime(config_path)
            return True  # Agora retorna True ao carregar com sucesso
    except FileNotFoundError:
        logging.error("Arquivo config.json n√£o encontrado.")
        print(f"ERRO: Crie o arquivo {config_path} ou ajuste o caminho")
    except json.JSONDecodeError:
        logging.error("Erro ao decodificar o arquivo config.json.")
    except Exception as e:
        logging.error(f"Erro inesperado ao carregar config.json: {e}")

# Fun√ß√£o para verificar se o arquivo foi modificado
def verificar_modificacao():
    """Verifica se o config.json foi modificado e recarrega"""
    global config, ultima_modificacao
    
    try:
        mod_time = os.path.getmtime('db/config.json')
        if mod_time != ultima_modificacao:
            logging.info("Recarregando agendamentos...")
            print("\nüîç Configura√ß√£o modificada - Recarregando...")
            
            if carregar_config():
                schedule.clear()
                agendar_requisicoes()
                
                # Registrar no log os NOVOS agendamentos (DEASTIVADO)
              #  logging.info("üìã Agendamentos Atuais:")
                for task in config.get('tasks', []):
                    if task.get('status', False):
                       
                       """  logging.info(
                            f"  - {task['hora']} | "
                            f"{task.get('description', task.get('url', 'N/A'))} | "
                            f"URL: {task['url']}"
                        ) """
                
                mostrar_agendamentos()  # Mostra tamb√©m no console
            else:
                print("‚ùå Erro ao carregar config, saindo do bloco.")
                
    except Exception as e:
        logging.error(f"Erro ao verificar modifica√ß√µes: {str(e)}")

# Fun√ß√£o para fazer a requisi√ß√£o GET
def fazer_get(url, description):

    try:
        resposta = requests.get(url, timeout=10)
        short_url = url.split('//')[-1][:30] + ('...' if len(url) > 30 else '')
        
        # Log e print da tentativa de requisi√ß√£o
        logging.info(f"Sucesso na chamada de: {short_url}")

        if resposta.status_code == 200:
            logging.info(f"Sucesso 200 resposta de: {description}")
            success_logger.info(f"Response from: {short_url}: {resposta.text}")

            print(f"‚úÖ Sucesso 200 {description} [{time.strftime('%H:%M')}]")
        else:
            logging.warning(f"‚ö†Ô∏è Falha: {short_url} (status {resposta.status_code})")
            print(f"‚ö†Ô∏è [{time.strftime('%H:%M')}] {short_url} ‚Üí Status {resposta.status_code}")
            
    except requests.exceptions.RequestException as e:
        logging.error(f" Erro: {short_url} ‚Üí {str(e)}")
        print(f"‚ùå Erro [{time.strftime('%H:%M')}] {short_url} ‚Üí {str(e)}")

# Teste com uma URL qualquer
# fazer_get("https://api-restful-json.vercel.app/status")

# Fun√ß√£o para agendar as requisi√ß√µes
def agendar_requisicoes():
    """Vers√£o unificada que mant√©m compatibilidade"""
    if not config or 'tasks' not in config:
        logging.error("Erro: Configura√ß√£o inv√°lida ou sem tarefas!")
        return

    for task in config['tasks']:
        # Modo Legado (para JSON sem description)
        if 'description' not in task:
            url = task.get('url')
            hora = task.get('hora')
            status = task.get('status', True)  # Default True para compatibilidade
            
            if not url or not hora:
                continue
                
            if not status:
                logging.info(f"Tarefa desativada (legado): {url}")
                print(f"üî¥ {hora} | {url} | DESATIVADA")
                continue
                
            schedule.every().day.at(hora).do(
                url=url,
                hora=hora
            )
            print(f"üü¢ {hora} | {url} | Agendada (legado)")
            continue

        # Modo Novo (com description)
        required_fields = ['description', 'url', 'status', 'hora']
        if not all(field in task for field in required_fields):
            logging.warning(f"Tarefa incompleta: {task.get('url', 'URL n√£o especificada')}")
            continue

        if not task['status']:
            logging.info(f" Tarefa desativada: {task['description']}")
            """ OUTRO MONITOR DE STAT """  
         #   print(f"üî¥ {task['hora']} | {task['description']} | DESATIVADA")
            continue

        schedule.every().day.at(task['hora']).do(
            executar_tarefa_se_ativa,
            task=task
        )

        """ OUTRO MONITOR DE STAT """
      #  print(f"üü¢ {task['hora']} | {task['description']} | Agendada")

        

# Nova fun√ß√£o executar_tarefa_se_ativa():
    """Executa a tarefa apenas se ainda estiver ativa no momento agendado"""
def executar_tarefa_se_ativa(task):
    """Executa a tarefa se ainda estiver ativa"""
    try:
        if not task.get('status', False):
            logging.info(f" Tarefa cancelada: {task['description']} (status alterado)")
            return
        
        fazer_get(task['url'], task['description'])

        # Execu√ß√£o com descri√ß√£o no log
        start_time = time.time()
        resposta = requests.get(task['url'], timeout=10)
        elapsed = time.time() - start_time

        log_msg = (
            f"‚úÖ {task['description']} | "
            f"Status: {resposta.status_code} | "
            f"Tempo: {elapsed:.2f}s"
        )
        # nao logar o sucesso no log principal logging.info(log_msg)
        #success_logger.info(f"Response from {task['url']} - {resposta.text}")

        #print(log_msg)

    except Exception as e:
        error_msg = f"‚ùå {task['description']} | Erro: {str(e)}"
        print(error_msg)
        logging.error(error_msg)


""" FN PARA MOSTRAR OS AGENDAMENTO - MELHORADO """
def mostrar_agendamentos():
    print("\nüìÖ Tarefas Agendadas:")
    print("HORA   | DESCRI√á√ÉO       | STATUS")
    print("-" * 40)
    
    for task in config.get('tasks', []):
        status = " ATIVO" if task.get('status', False) else " INATIVO"
        status2 = " üü¢" if task.get('status', False) else " üî¥"
       # print(f"{task['hora']} | {task['description'][:15]:<15} | {status}")
        linha = f"{task['hora']} | {task['description'][:15]:<15} | {status2}"
        print(linha)
        logging.info(f"{task['hora']} | {task['description'][:15]:<15} | {status}")  


# Fun√ß√£o para recarregar os agendamentos
def recarregar_agendamentos():
    logging.info("Recarregando agendamentos...")
    schedule.clear()  # Limpa todos os agendamentos existentes
    agendar_requisicoes()  # Agenda as requisi√ß√µes com as novas configura√ß√µes

# Inicializar o carregamento do config.json e agendar as requisi√ß√µes
#carregar_config()
agendar_requisicoes()

# Loop principal para verificar modifica√ß√µes e rodar o agendador
if __name__ == "__main__":
    print("Script iniciado...")
    intervalo_verificacao = 5  # Verificar a cada 5 segundos
    
    # Carrega a configura√ß√£o inicial
    if not carregar_config():
       print("‚ùå Falha ao carregar config.json!")
       exit()

    mostrar_agendamentos()  # Exibe o resumo
    agendar_requisicoes()   # Inicia o agendador

    try:
        last_check = time.time()
        while True:
            # Verifica modifica√ß√µes no intervalo configurado
            if time.time() - last_check >= intervalo_verificacao:
                verificar_modificacao()
                last_check = time.time()
            
            schedule.run_pending()  # Executa as tarefas agendadas
            time.sleep(1)  # Espera 1 segundo

    except KeyboardInterrupt:
        logging.info("Script interrompido pelo usu√°rio.")
        print("\nüõë Script finalizado pelo usu√°rio")